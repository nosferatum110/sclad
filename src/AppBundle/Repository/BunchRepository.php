<?php

namespace AppBundle\Repository;

use \AppBundle\Entity\Bunch;
use AppBundle\Entity\ProductCrossout;
use AppBundle\Entity\ProductStock;
use AppBundle\Entity\ProductSale;

/**
 * BunchRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class BunchRepository extends \Doctrine\ORM\EntityRepository
{
    /**
     * findSimilarNames
     * 
     * @param type $title
     */
    public function findSimilarNames($title)
    {
        $result = $this->createQueryBuilder('b')
           ->where('b.title LIKE :title')
           ->setParameter('title', '%' . $title . '%')
           ->getQuery()
           ->getResult();
        
        return $result;
    }

    /**
     * getProductsByBunch
     *
     * @param $bunch
     * @return array
     */
    public function getProductsByBunch($bunch)
    {
        if ($bunch instanceof Bunch) {
            $bunch_id = $bunch->getId();
        } else {
            $bunch_id = $bunch;
        }

        $result = $this->createQueryBuilder('p')
             ->where('p.bunch_id = :bunch_id')
             ->setParameter('bunch_id', $bunch_id)
             ->getQuery()
             ->getResult();

        return $result;
    }

    /**
     * Search By
     *
     * @param array $terms
     * @param $paginator
     * @return mixed
     */
    public function searchBy(array $terms, $paginator)
    {
        $query = $this->getQueryByTerms($terms);
        $pagination = $paginator->paginate($query, $terms['page'], $terms['limit']);

        return $pagination;
    }

    /**
     * findAllBy
     *
     * @param array $terms
     * @return array
     */
    public function findAllBy(array $terms)
    {
        $query = $this->getQueryByTerms($terms);
        return $query->getQuery()->getResult();
    }

    /**
     * searchProductSaleBy
     *
     * @param array $terms
     * @param $paginator
     * @return mixed
     */
    public function searchProductSaleBy(array $terms, $paginator)
    {
        $query = $this->getPaginationQueryForProductSale($terms);
        $pagination = $paginator->paginate($query, $terms['page'], $terms['limit']);

        return $pagination;
    }

    /**
     * searchProductSaleNotCrossoutBy
     *
     * @param array $terms
     * @param $paginator
     * @return mixed
     */
    public function searchProductSaleNotCrossoutBy(array $terms, $paginator)
    {
        $query = $this->getPaginationQueryForProductSaleNotCrossout($terms);
        $pagination = $paginator->paginate($query, $terms['page'], $terms['limit']);

        return $pagination;
    }

    /**
     * getPaginationQueryForProductSale
     *
     * @param $terms
     * @param $page
     * @param int $limit
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getPaginationQueryForProductSaleNotCrossout($terms)
    {
        /* @var $qb \Doctrine\ORM\QueryBuilder */
        $qb = $this->createQueryBuilder('b');
        $qb->innerJoin(ProductSale::class, 'ps', 'WITH', 'b.id=ps.bunchId');
        $qb->leftJoin(ProductCrossout::class, 'pc', 'WITH', 'ps.id=pc.productSaleId');
        $qb->groupBy('ps.id');
        $qb->addSelect('SUM(ps.qty) AS total');
        $qb->where('pc.id IS NULL');

        // filters data
        if (isset($terms['priceFrom']) && !empty($terms['priceFrom'])) {
            $qb->andWhere('ps.price >= :price_from');
            $qb->setParameter('price_from', $terms['priceFrom']);
        }
        if (isset($terms['priceTo']) && !empty($terms['priceTo'])) {
            $qb->andWhere('ps.price <= :price_to');
            $qb->setParameter('price_to', $terms['priceTo']);
        }
        if (isset($terms['dateFrom']) && !empty($terms['dateFrom'])) {
            $dateFrom = \DateTime::createFromFormat('Y.m.d', $terms['dateFrom']);
            $qb->andWhere('ps.date >= :date_from');
            $qb->setParameter('date_from', $dateFrom->format('Y-m-d 00:00:00'));
        }
        if (isset($terms['dateTo']) && !empty($terms['dateTo'])) {
            $dateTo = \DateTime::createFromFormat('Y.m.d', $terms['dateTo']);
            $qb->andWhere('ps.date <= :date_to');
            $qb->setParameter('date_to', $dateTo->format('Y-m-d 23:59:59'));
        }
        if (isset($terms['providerId']) && !empty($terms['providerId'])) {
            $defined = false;
            foreach($qb->getDQLPart('join')['b'] as $item) {
                if ($item->getJoin() == ProductStock::class) $defined = true;
            }
            if ($defined === false) {
                $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
            }
            $qb->andWhere('p.providerId = :provider_id')
                ->setParameter('provider_id', $terms['providerId']);
        }
        if (isset($terms['title']) && !empty($terms['title'])) {
            $defined = false;
            foreach($qb->getDQLPart('join')['b'] as $item) {
                if ($item->getJoin() == ProductStock::class) $defined = true;
            }
            if ($defined === false) {
                $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
            }
            $qb->andWhere('p.title LIKE :title')
                ->setParameter('title', '%'.$terms['title'].'%');
        }

        // sort by data
        if (isset($terms['sortCol']) && !empty($terms['sortCol'])) {
            $order = $terms['sortOrder'] ? $terms['sortOrder'] : 'ASC';
            if ($terms['sortCol'] == 'price-purchase-min-byn') {
                $defined = false;
                foreach($qb->getDQLPart('join')['b'] as $item) {
                    if ($item->getJoin() == ProductStock::class) $defined = true;
                }
                if ($defined === false) {
                    $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
                }
                $qb->addSelect('MIN(p.priceByn) AS min_price');
                $qb->orderBy('min_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'price-purchase-min') {
                $defined = false;
                foreach($qb->getDQLPart('join')['b'] as $item) {
                    if ($item->getJoin() == ProductStock::class) $defined = true;
                }
                if ($defined === false) {
                    $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
                }
                $qb->addSelect('MIN(p.price) AS min_price');
                $qb->orderBy('min_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'price-sale-min' || $terms['sortCol'] == 'price-sale-min-byn') {
                $qb->addSelect('MIN(ps.price) AS min_price');
                $qb->orderBy('min_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'date') {
                $qb->orderBy('ps.date', $order);
            }
        }

        return $qb;
    }

    /**
     * getPaginationQueryForProductSale
     *
     * @param $terms
     * @param $page
     * @param int $limit
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getPaginationQueryForProductSale($terms)
    {
        /* @var $qb \Doctrine\ORM\QueryBuilder */
        $qb = $this->createQueryBuilder('b');
        $qb->innerJoin(ProductSale::class, 'ps', 'WITH', 'b.id=ps.bunchId');

        // filters data
        if (isset($terms['priceFrom']) && !empty($terms['priceFrom'])) {
            $qb->andWhere('ps.price >= :price_from');
            $qb->setParameter('price_from', $terms['priceFrom']);
        }
        if (isset($terms['priceTo']) && !empty($terms['priceTo'])) {
            $qb->andWhere('ps.price <= :price_to');
            $qb->setParameter('price_to', $terms['priceTo']);
        }
        if (isset($terms['dateFrom']) && !empty($terms['dateFrom'])) {
            $dateFrom = \DateTime::createFromFormat('Y.m.d', $terms['dateFrom']);
            $qb->andWhere('ps.date >= :date_from');
            $qb->setParameter('date_from', $dateFrom->format('Y-m-d 00:00:00'));
        }
        if (isset($terms['dateTo']) && !empty($terms['dateTo'])) {
            $dateTo = \DateTime::createFromFormat('Y.m.d', $terms['dateTo']);
            $qb->andWhere('ps.date <= :date_to');
            $qb->setParameter('date_to', $dateTo->format('Y-m-d 23:59:59'));
        }
        if (isset($terms['providerId']) && !empty($terms['providerId'])) {
            $defined = false;
            foreach($qb->getDQLPart('join')['b'] as $item) {
                if ($item->getJoin() == ProductStock::class) $defined = true;
            }
            if ($defined === false) {
                $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
            }
            $qb->andWhere('p.providerId = :provider_id')
                ->setParameter('provider_id', $terms['providerId']);
        }
        if (isset($terms['title']) && !empty($terms['title'])) {
            $defined = false;
            foreach($qb->getDQLPart('join')['b'] as $item) {
                if ($item->getJoin() == ProductStock::class) $defined = true;
            }
            if ($defined === false) {
                $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'ps.productId=p.id');
            }
            $qb->andWhere('p.title LIKE :title')
                ->setParameter('title', '%'.$terms['title'].'%');
        }

        // sort by data
        if (isset($terms['sortCol']) && !empty($terms['sortCol'])) {
            $order = $terms['sortOrder'] ? $terms['sortOrder'] : 'ASC';
            if ($terms['sortCol'] == 'title') {
                $qb->orderBy('b.title', $order);
            }
            if ($terms['sortCol'] == 'last-date') {
                //$qb->addSelect('MIN(p.created) AS last_date');
                $qb->orderBy('last_date', $order);
                //$qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'total') {
                $qb->orderBy('b.total', $order);
            }
            if ($terms['sortCol'] == 'last-price') {
                $qb->addSelect('MIN(p.priceByn) AS last_price');
                $qb->orderBy('last_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'average-price-byn') {
                $qb->addSelect('MIN(p.priceByn) AS avg_byn');
                $qb->orderBy('avg_byn', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'price-min-byn') {
                $qb->addSelect('MIN(p.priceByn) AS min_price');
                $qb->orderBy('min_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'price-min') {
                $qb->addSelect('MIN(p.price) AS min_price');
                $qb->orderBy('min_price', $order);
                $qb->groupBy('b.id');
            }
            if ($terms['sortCol'] == 'average-price') {
                $qb->addSelect('AVG(p.price) AS avg_price');
                $qb->orderBy('avg_price', $order);
                $qb->groupBy('b.id');
            }
        }

        return $qb;
    }

    /**
     * getPaginationQuery
     *
     * @param $terms
     * @param $page
     * @param int $limit
     * @return \Doctrine\ORM\QueryBuilder
     */
    public function getQueryByTerms($terms)
    {
        /* @var $qb \Doctrine\ORM\QueryBuilder */
        $qb = $this->createQueryBuilder('b');

        $qb->innerJoin(ProductStock::class, 'p', 'WITH', 'b.id=p.bunchId');

        $qb->addSelect('DATE_FORMAT(MIN(p.created), \'%d-%m-%Y\') AS last_date');
        $qb->groupBy('b.id');

        $qb->andWhere('b.total <> 0');

        // filters data
        if (isset($terms['documents']) && $terms['documents'] != "") {
            $qb->andWhere('p.documents = :documents');
            $qb->setParameter('documents', $terms['documents']);
        }
        if (isset($terms['priceFrom']) && !empty($terms['priceFrom'])) {
            $qb->andWhere('p.priceByn >= :price_from');
            $qb->setParameter('price_from', $terms['priceFrom']);
        }
        if (isset($terms['priceTo']) && !empty($terms['priceTo'])) {
            $qb->andWhere('p.priceByn <= :price_to');
            $qb->setParameter('price_to', $terms['priceTo']);
        }
        if (isset($terms['dateFrom']) && !empty($terms['dateFrom'])) {
            $dateFrom = \DateTime::createFromFormat('Y.m.d', $terms['dateFrom']);
            $qb->andWhere('p.created >= :date_from');
            $qb->setParameter('date_from', $dateFrom->format('Y-m-d 00:00:00'));
        }
        if (isset($terms['dateTo']) && !empty($terms['dateTo'])) {
            $dateTo = \DateTime::createFromFormat('Y.m.d', $terms['dateTo']);
            $qb->andWhere('p.created <= :date_to');
            $qb->setParameter('date_to', $dateTo->format('Y-m-d 23:59:59'));
        }
        if (isset($terms['providerId']) && !empty($terms['providerId'])) {
            $qb->andWhere('p.providerId = :provider_id')
                ->setParameter('provider_id', $terms['providerId']);
        }
        if (isset($terms['title']) && !empty($terms['title'])) {
            $qb->andWhere('p.title LIKE :title')
                ->setParameter('title', '%'.$terms['title'].'%');
        }

        // sort by data
        if (isset($terms['sortCol']) && !empty($terms['sortCol'])) {
            $order = $terms['sortOrder'] ? $terms['sortOrder'] : 'ASC';
            if ($terms['sortCol'] == 'title') {
                $qb->orderBy('b.title', $order);
            }
            if ($terms['sortCol'] == 'last-date') {
                //$qb->addSelect('MIN(p.created) AS last_date');
                $qb->orderBy('last_date', $order);
            }
            if ($terms['sortCol'] == 'total') {
                $qb->orderBy('b.total', $order);
            }
            if ($terms['sortCol'] == 'last-price') {
                $qb->addSelect('MIN(p.priceByn) AS last_price');
                $qb->orderBy('last_price', $order);
            }
            if ($terms['sortCol'] == 'average-price-byn') {
                $qb->addSelect('MIN(p.priceByn) AS avg_byn');
                $qb->orderBy('avg_byn', $order);
            }
            if ($terms['sortCol'] == 'price-min-byn') {
                $qb->addSelect('MIN(p.priceByn) AS min_price');
                $qb->orderBy('min_price', $order);
            }
            if ($terms['sortCol'] == 'price-min') {
                $qb->addSelect('MIN(p.price) AS min_price');
                $qb->orderBy('min_price', $order);
            }
            if ($terms['sortCol'] == 'average-price') {
                $qb->addSelect('AVG(p.price) AS avg_price');
                $qb->orderBy('avg_price', $order);
            }
        }
        else {
            // default sort
            $qb->orderBy('last_date', 'DESC');
            $qb->addOrderBy('b.id', 'ASC');
        }

        return $qb;
    }

    /**
     * recalcTotalFor
     *
     * @param Bunch $bunch
     * @return $this
     */
    public function recalcTotalFor(Bunch $bunch)
    {
        $em = $this->getEntityManager();
        $qb = $this->createQueryBuilder('b')
                    ->select('SUM(p.qty) AS qty')
                    ->leftJoin(ProductStock::class, 'p', 'WITH', 'p.bunchId=b.id')
                    ->where('b.id = :id')
                    ->setParameter('id', $bunch->getId())
                    ->groupBy('b.id');

        $result = $qb->getQuery()->getResult();

        if (!empty($result)) {
            $bunch->setTotal($result[0]['qty']);
        }
        else {
            $bunch->setTotal(0);
        }

        $em->persist($bunch);
        $em->flush();

        return $this;
    }

    /**
     * Get Total
     *
     * @return array
     */
    public function getTotal($terms)
    {
        $total = [];
        $qb = $this->getQueryByTerms($terms);
        $qb->resetDQLPart('groupBy');
        $qb->resetDQLPart('orderBy');
        $qb->select('SUM(p.price*p.qty) AS total_price,
                                SUM(p.qty) AS total_qty,
                                SUM(p.priceByn*p.qty) AS total_price_byn');
        $result = $qb->getQuery()->getResult();

        if (isset($result[0]['total_qty'])) {
            $total['qty'] = $result[0]['total_qty'];
            $total['price'] = $result[0]['total_price'];
            $total['price_byn'] = $result[0]['total_price_byn'];
        }

        return $total;
    }
}
